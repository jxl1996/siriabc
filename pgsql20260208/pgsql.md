## 1 安装

### 1.1 Windows安装

安装检查:

```
C:\Users\jxl>psql --version
psql (PostgreSQL) 18.1
```

如果不生效,就将安装目录下的/bin添加到环境变量path中: 例如 D:\Program\PostgreSQL\18\bin

再次检查:

```
C:\Users\jxl>psql --version
psql (PostgreSQL) 18.1

C:\Users\jxl>psql -U postgres
用户 postgres 的口令：

psql (18.1)
输入 "help" 来获取帮助信息.

postgres=#
```

psql -U postgres:  -U是用户名  postgres是默认用户

### 1.2 Linux安装

安装检查:

```
切换到postgres用户:
sudo -i -u postgres

检查版本:
-bash-4.2$ psql --version
psql (PostgreSQL) 18.0

进入到psql命令行:
psql

创建一个测试数据库:
postgres=# create database testdb;
CREATE DATABASE

连接到指定数据库:
postgres=# \c testdb
You are now connected to database "testdb" as user "postgres".
testdb=# 

退出数据库:
testdb=# \q

--------------------------------
连接数据库方法二:
-U 指定用户名  -d 指定数据库
-bash-4.2$ psql -U postgres -d testdb
psql (18.0)
Type "help" for help.

testdb=# 


检查可用的数据库:
\l


```

## 2. 数据库和表操作

### 2.1 查询版本

```
查询版本:
SELECT version();

```

### 2.2 创建表

```sql
CREATE TABLE "finance"."employees" (
  "emp_id" int4,
  "name" varchar(100),
  "hire_date" date,
  "salary" numeric(10,2),
  "extra_details" jsonb,
  "email_id" varchar(50)
);
```

查询存在的表:

```cmd
C:\Users\jxl>psql -U postgres -d testdb2
用户 postgres 的口令：

psql (18.1)
输入 "help" 来获取帮助信息.

testdb2=# \dt
              List of tables
 架构模式 |   名称    |  类型  |  拥有者
----------+-----------+--------+----------
 public   | employees | 数据表 | postgres
(1 行记录)
```



### 2.3 约束

```sql
create table employees_with_constrints (
	emp_id INTEGER PRIMARY KEY,
	name VARCHAR(100) NOT NULL,
	hire_date DATE NOT NULL,
	salary NUMERIC(10,2) CHECK (salary >= 0),
	emailId VARCHAR(50) UNIQUE,
	extra_details JSONB
);
```

查看表结构及其约束:

```cmd
testdb2=# \d employees_with_constrints
              数据表 "public.employees_with_constrints"
     栏位      |          类型          | 校对规则 |  可空的  | 预设
---------------+------------------------+----------+----------+------
 emp_id        | integer                |          | not null |
 name          | character varying(100) |          | not null |
 hire_date     | date                   |          | not null |
 salary        | numeric(10,2)          |          |          |
 emailid       | character varying(50)  |          |          |
 extra_details | jsonb                  |          |          |
索引：
    "employees_with_constrints_pkey" PRIMARY KEY, btree (emp_id)
    "employees_with_constrints_emailid_key" UNIQUE CONSTRAINT, btree (emailid)
检查约束限制
    "employees_with_constrints_salary_check" CHECK (salary >= 0::numeric)
```



### 2.4 SERIAL与自增列

```sql
CREATE TABLE employees_copy ( emp_id SERIAL PRIMARY KEY, full_name TEXT NOT NULL, salary NUMERIC ( 10, 2 ) );


插入一行数据: 注意'zhangsan'是单引号
INSERT INTO employees_copy ( full_name, salary )
VALUES
	('zhangsan', 5000 );
```

> [!IMPORTANT]
>
> 注意:
>
> pgsql中的int4类型: 4表示 4个字节 32位
>
> golang中的int32类型: 32 表示32位 



### 2.5 标识列

GENERATED BY DEFAULT AS IDENTITY : 允许手动插入id

```sql
CREATE TABLE employees
( emp_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, 
	full_name TEXT NOT NULL, 
	salary NUMERIC ( 10, 2 ) 
);

INSERT INTO employees VALUES (1,'jxl',9000);  # 手动插入ID 可以正常执行
INSERT INTO employees (full_name,salary) VALUES ('lisi',8000);
INSERT INTO employees (full_name,salary) VALUES ('wangwu',7000);
```



GENERATED ALWAYS AS IDENTITY: 不允许手动插入ID

```sql
CREATE TABLE employees2
( emp_id INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY, 
	full_name TEXT NOT NULL, 
	salary NUMERIC ( 10, 2 ) 
);

INSERT INTO employees2 VALUES (1,'jxl',9000);  # 报错 不允许手动插入ID
INSERT INTO employees2 (full_name,salary) VALUES ('lisi',8000);
INSERT INTO employees2 (full_name,salary) VALUES ('wangwu',7000);
```

### 2.6 DDL命令

创建数据库:

```
create database <database_name>;
```

基础的DDL语句:

```sql
-- 添加一个部门列
ALTER TABLE employees ADD department VARCHAR(100);

-- 删除列
ALTER TABLE employees DROP COLUMN department; 

-- 重命名列
ALTER TABLE employees RENAME full_name TO username;

-- 更新列类型
ALTER TABLE employees ALTER column department TYPE varchar(50);

-- 重命名表名
ALTER TABLE employees RENAME TO staff;

-- 删除表
DROP TABLE staff;
```

列出所有表以及查看表结构:

```cmd
testdb2=# \dt
              List of tables
 架构模式 |    名称    |  类型  |  拥有者
----------+------------+--------+----------
 public   | employees2 | 数据表 | postgres
 public   | employees3 | 数据表 | postgres
 public   | staff      | 数据表 | postgres
(3 行记录)


testdb2=# \d staff
                               数据表 "public.staff"
   栏位   |     类型      | 校对规则 |  可空的  |               预设
----------+---------------+----------+----------+----------------------------------
 emp_id   | integer       |          | not null | generated by default as identity
 username | text          |          | not null |
 salary   | numeric(10,2) |          |          |
索引：
    "employees_pkey" PRIMARY KEY, btree (emp_id)
```

### 2.7 表级约束

```sql
CREATE TABLE employee_details (
	dep_id INT,
	designation VARCHAR ( 100 ),
	emp_ref INT,
	PRIMARY KEY ( dep_id, emp_ref ),
FOREIGN KEY ( emp_ref ) REFERENCES employees ( emp_id ) 
) INHERITS ( employees );
```



## 3. 增删改查

### 3.1 基础操作

插入数据:

```sql
-- 写法1
INSERT INTO employees ( full_name, salary, hire_date, extra )
VALUES ( '狗娃', 12000, '2021-12-15', '{"hobbies":["music","sleep"]}' );
	
-- 写法2
INSERT INTO employees VALUES (100,'狗剩', 11000, '2021-12-10', '{"hobbies":["game","sleep"]}');

-- 批量插入
INSERT INTO employees ( full_name, salary, hire_date, extra ) VALUES 
( '张三', 12000, '2021-12-15', '{"hobbies":["music","sleep"]}' ),
( '李四', 12000, '2021-12-15', '{"hobbies":["music","sleep"]}' ),
( '王五', 12000, '2021-12-15', '{"hobbies":["music","sleep"]}' );
```

查询数据:

```sql
SELECT full_name, salary FROM employees WHERE salary < 10000 ORDER BY salary asc;
```

更新数据:

```sql
UPDATE employees SET full_name='张三丰' , salary=99999 WHERE emp_id = 6;

UPDATE employees SET salary = salary + 5000 WHERE salary < 10000;
```

删除数据:

```sql
DELETE FROM employees WHERE emp_id = 1;

-- json条件
SELECT * FROM employees WHERE extra::text like '%"certified": true&';
DELETE FROM employees  WHERE extra::text like '%"certified": false%';


-- 清空表
DELETE FROM employees;
TRUNCATE TABLE employees;
```

## 4. JSON条件查询

准备表结构:

```sql
CREATE TABLE users (
	id bigserial PRIMARY key,
	profile JSONB
);
```

准备测试数据:

```sql
INSERT INTO users ( profile )
VALUES
	( '{
		"name": "Tom",
		"age": 28,
		"roles": ["admin", "editor"],
		"address": {
    "city": "Taipei",
    "zip": "100"
		},
		"active": true
	}' ),
	( '{
		"name": "Jake",
		"age": 30,
		"roles": ["admin", "test"],
		"address": {
    "city": "Taipei",
    "zip": "100"
		},
		"active": true
	}' ),
	( '{
		"name": "Lily",
		"age": 35,
		"roles": ["admin", "editor"],
		"address": {
    "city": "Chengdu",
    "zip": "120"
		},
  "active": false
	}' );
```

### 4.1 模糊匹配

```sql
SELECT * FROM users WHERE profile::text like '%"active": false%';
```

### 4.2 取值判断

取文本:

```sql
-- 按字段精准查询
SELECT * FROM users WHERE profile->>'name' = 'Jake';

-- 按字段模糊查询
SELECT * FROM users WHERE profile->>'name' like '%Tomo%';
```

数值比较(重点坑):

```sql
-- 数值比较
SELECT * FROM users WHERE (profile->>'age')::int >=30;
```

> [!IMPORTANT]
>
> **一定要转型**
>  否则是字符串比较。

布尔判断: 

```sql
SELECT * FROM users WHERE (profile->>'active')::boolean = true;
```

### 4.3 jsonb 包含查询（王炸）

判断包含某个键值对: 

```sql
-- 方式1 使用模糊查询来实现(不推荐)
SELECT * FROM users WHERE profile::text like '%"name": "Tom"%';

-- 方式2 推荐用法
-- ✔ 支持 GIN 索引
-- ✔ 性能最好
-- ✔ 强烈推荐
SELECT * FROM users WHERE profile @> '{"name":"Tom"}'
```

嵌套对象匹配:

```sql
SELECT * FROM users WHERE profile @> '{"address":{"city":"Chengdu"}}';
SELECT * FROM users WHERE profile @> '{"address":{"zip":"100"}}';

-- 注意:对于判断数组类型的字段中是否包含某值, 同样有效!!!
SELECT * FROM users WHERE profile @> '{"roles":["editor"]}';
```



### 4.4 key是否存在

查询jsonb字段`profile`中 包含username字段的行:

```sql
SELECT * FROM users WHERE profile  ? 'username';
```

查询jsonb字段`profile`中 包含username字段或者包含name字段的行:

```sql
SELECT * FROM users WHERE profile  ?| array['username','name'];
```

查询jsonb字段`profile`中 同事包含username字段和name字段的行:

```sql
SELECT * FROM users WHERE profile  ?& array['username','roles'];
```



### 4.5 数组条件查询

数组包含某个值:

```sql
-- 方式1 
SELECT * FROM users WHERE profile @> '{"roles":["test"]}';

-- 方式2 推荐
SELECT * FROM users WHERE profile->'roles' ? 'test';
```

数组包含多个值:

```sql
-- 方式1 
SELECT * FROM users WHERE profile @> '{"roles":["test","admin"]}';

-- 方式2 推荐
SELECT * FROM users WHERE profile->'roles' @> '["test","admin"]';
```



### 4.6 复杂条件

多条件组合:

```sql
SELECT *
FROM users
WHERE profile @> '{"active": true}'
  AND (profile->>'age')::int BETWEEN 25 AND 35
  AND profile->'roles' ? 'admin';
```

逻辑OR:

```sql
SELECT *
FROM users
WHERE profile @> '{"roles": ["test"]}'
   OR profile->'roles' ? 'admin';

```

### 4.7 性能与索引（非常重要）

推荐索引（90% 场景）

```sql
CREATE INDEX idx_users_profile ON users USING GIN (profile);

```

表达式索引（精确字段）: 只适合**热点字段**

```sql
CREATE INDEX idx_users_city
ON users ((profile->'address'->>'city'));

```



## 5. 高级查询

### 5.1 去重

```sql
-- 对薪水去重
SELECT  DISTINCT  salary FROM employees;

-- 对名字和薪水的组合去重
SELECT  DISTINCT  full_name, salary FROM employees ORDER BY salary asc;
```

> [!NOTE]
>
> 注意: `distinct`关键字只能出现在所有查询字段之前

### 5.2 聚合函数

```sql
-- 求行总数
SELECT count(*) FROM employees;
-- 只查询非空值的行数
SELECT count(info) FROM employees;

-- 求和
SELECT sum(salary) FROM employees;
-- 最大值
SELECT max(salary) FROM employees;
-- 最小值
SELECT min(salary) FROM employees;
-- 平均值
SELECT avg(salary) FROM employees;
```

小数位处理:

```sql
-- 四舍五入取整
SELECT round(avg(salary)) as avgsalary FROM employees;
-- 向下取整
SELECT floor(avg(salary)) as avgsalary FROM employees;
-- 向上取整
SELECT ceil(avg(salary)) as avgsalary FROM employees;
-- 保留2位小数
SELECT round(avg(salary),2) as avgsalary FROM employees;

-- 保留2位小数 推荐写法
SELECT avg(salary)::numeric(12,2) as avgsalary FROM employees;
SELECT round(avg(salary),2)::numeric as avgsalary FROM employees;

-- 四舍五入取整的另一种写法
-- PostgreSQL 18 中 numeric::int 已经是四舍五入。但生产代码里，永远不要依赖 cast 的“隐式取整规则”。
SELECT avg(salary)::int FROM employees;
```

`numeric(12,2)` 里的 `12` 表示“总有效位数”，不是整数位数。

### 5.3 limit限制行数

```sql
-- 查询前3行
SELECT * FROM employees ORDER BY emp_id limit 3 ;

-- 跳过2行,再查询前3行
SELECT * FROM employees ORDER BY emp_id limit 3 OFFSET 2;
```

### 5.4 分组

```sql
SELECT city, avg(salary)::numeric(12,2) as avg_salary FROM employees GROUP BY city;

SELECT city, count(*) as cnts FROM employees GROUP BY city;
```



### 5.5 分组过滤

`having` 可以对分组查询的结果进行二次过滤.

```sql
SELECT city, avg(salary)::numeric(12,2) as avg_salary FROM employees GROUP BY city HAVING avg(salary)::numeric(12,2)  > 12000;

SELECT city, count(*) as cnts FROM employees GROUP BY city HAVING count(*) >=3;
```



## 6. 连接和子查询

### 6.1 内连接

![image-20260209005047225](./assets/image-20260209005047225.png)

创建测试表并添加测试数据:

```sql
-- 员工表
CREATE TABLE "public"."emps" (
  "id" int8 NOT NULL DEFAULT nextval('emps_id_seq'::regclass),
  "name" varchar(255) COLLATE "pg_catalog"."default",
  "dept_id" int4,
  CONSTRAINT "emps_pkey" PRIMARY KEY ("id")
);

-- 部门表
CREATE TABLE "public"."depts" (
  "id" int8 NOT NULL DEFAULT nextval('depts_id_seq'::regclass),
  "name" varchar(255) COLLATE "pg_catalog"."default",
  CONSTRAINT "depts_pkey" PRIMARY KEY ("id")
);

INSERT INTO "public"."emps" ("id", "name", "dept_id") VALUES (1, '张三', 1);
INSERT INTO "public"."emps" ("id", "name", "dept_id") VALUES (2, '李四', 2);
INSERT INTO "public"."emps" ("id", "name", "dept_id") VALUES (3, '王五', 3);
INSERT INTO "public"."emps" ("id", "name", "dept_id") VALUES (4, '赵六', NULL);
INSERT INTO "public"."emps" ("id", "name", "dept_id") VALUES (5, '狗娃', NULL);

INSERT INTO "public"."depts" ("id", "name") VALUES (1, '研发部');
INSERT INTO "public"."depts" ("id", "name") VALUES (2, '测试部');
INSERT INTO "public"."depts" ("id", "name") VALUES (3, '测试部');
INSERT INTO "public"."depts" ("id", "name") VALUES (4, '市场部');

```

使用内连接查询:

```
mydb=# SELECT e.name as emp_name,d.name dep_name FROM emps e INNER JOIN depts d on e.dept_id = d.id;
 emp_name | dep_name
----------+----------
 张三     | 研发部
 李四     | 测试部
 王五     | 测试部
(3 行记录)
```

上面的查询结果: 不包含没有部门的员工, 以及没有员工的部门

### 6.2 左外连接和右外连接

![image-20260209005353270](./assets/image-20260209005353270.png)

使用左外连接查询:

```
mydb=# SELECT e.name as emp_name,d.name dep_name FROM emps e left JOIN depts d on e.dept_id = d.id;
 emp_name | dep_name
----------+----------
 张三     | 研发部
 李四     | 测试部
 王五     | 测试部
 赵六     |
 狗娃     |
(5 行记录)
```

使用右外连接查询:

```
mydb=# SELECT e.name as emp_name,d.name dep_name FROM emps e right JOIN depts d on e.dept_id = d.id;
 emp_name | dep_name
----------+----------
 张三     | 研发部
 李四     | 测试部
 王五     | 测试部
          | 市场部
(4 行记录)
```



### 6.3 全外连接

![image-20260209013602856](./assets/image-20260209013602856.png)

使用全外连接查询:

```
mydb=# SELECT e.name as emp_name,d.name dep_name FROM emps e full JOIN depts d on e.dept_id = d.id;
 emp_name | dep_name
----------+----------
 张三     | 研发部
 李四     | 测试部
 王五     | 测试部
 赵六     |
 狗娃     |
          | 市场部
(6 行记录)
```

上面的语句查询结果: 包含员工表所有数据以及部门表所有数据, 包括没有部门的员工 以及没有员工的部门

### 6.4 自连接

```
mydb=# SELECT e.name as empname ,m.name as managername FROM emps e  join emps m on e.manager_id = m.id;
 empname | managername
---------+-------------
 赵六    | 李四
 狗剩    | 李四
 狗娃    | 赵六
 铁柱    | 赵六
 嘎子    | 王五
(5 行记录)
```

> [!IMPORTANT]
>
> 注意: `JOIN` **前面什么都不写时，默认就是 `INNER JOIN`**。

### 6.5 交叉连接

交叉连接: 会将一个表的每一行和另一个表每一行进行组合.

案例: 查询出所有员工的所有排班可能性

```
mydb=# SELECT e.name as empname ,w.name as workshift FROM emps e CROSS JOIN work_shifts w;
 empname | workshift
---------+-----------
 张三    | 早班
 张三    | 中班
 张三    | 晚班
 李四    | 早班
 李四    | 中班
 李四    | 晚班
 王五    | 早班
 王五    | 中班
 王五    | 晚班
 赵六    | 早班
 赵六    | 中班
 赵六    | 晚班
 狗剩    | 早班
 狗剩    | 中班
 狗剩    | 晚班
 狗娃    | 早班
 狗娃    | 中班
 狗娃    | 晚班
 铁柱    | 早班
 铁柱    | 中班
 铁柱    | 晚班
 嘎子    | 早班
 嘎子    | 中班
 嘎子    | 晚班
(24 行记录)
```

上面的案例中: 员工表8条数据, 排班表3条数据, 所以总结果为24条数据.

### 6.6 子查询

案例1( 在where中使用子查询 ): 查询出工资高于平均工资的员工

```sql
SELECT
	* 
FROM
	employees 
WHERE
	salary > ( SELECT AVG ( salary ) avgsal FROM employees );
```

案例2( 在select中使用子查询 ): 查询每个员工的工资以及平均工资用于比较

```sql
SELECT
	*,
	( SELECT AVG ( salary ) FROM employees ) AS avgsal 
FROM
	employees;
```

### 6.7 公共表表达式(CTE)

CTE（Common Table Expression）= 给一段子查询起名字

建表并插入测试数据:

```sql
-- 用户表
CREATE TABLE users (
  id        BIGSERIAL PRIMARY KEY,
  name      TEXT NOT NULL,
  profile   JSONB NOT NULL,
  created_at TIMESTAMP DEFAULT now()
);

-- 测试数据
INSERT INTO users (name, profile) VALUES
('Alice',  '{"active": true,  "age": 28}'),
('Bob',    '{"active": false, "age": 35}'),
('Carol',  '{"active": true,  "age": 22}'),
('Dave',   '{"active": false, "age": 41}'),
('Eve',    '{"active": true,  "age": 30}');

-- 订单表
CREATE TABLE orders (
  id         BIGSERIAL PRIMARY KEY,
  user_id    BIGINT NOT NULL,
  amount     NUMERIC(10,2) NOT NULL,
  created_at TIMESTAMP DEFAULT now()
);
CREATE INDEX idx_orders_user_id ON orders(user_id);

-- 测试数据
INSERT INTO orders (user_id, amount) VALUES
-- Alice (id = 1)
(1,  99.90),
(1,  49.00),
(1, 199.00),
(1,  29.90),
(1,  59.00),
(1,  19.90),

-- Bob (id = 2)
(2,  88.00),
(2,  15.00),

-- Carol (id = 3)
(3, 120.00),
(3, 220.00),
(3,  35.00),
(3,  60.00),
(3,  80.00),
(3,  40.00),

-- Dave (id = 4)
(4,  10.00),

-- Eve (id = 5)
(5, 300.00),
(5, 180.00),
(5,  90.00);


-- 分类表
CREATE TABLE categories (
  id        BIGSERIAL PRIMARY KEY,
  parent_id BIGINT,
  name      TEXT NOT NULL
);

-- 测试数据
INSERT INTO categories (parent_id, name) VALUES
(NULL, 'Tech'),          -- 1
(NULL, 'Life'),          -- 2

(1, 'Programming'),      -- 3
(1, 'Hardware'),         -- 4

(3, 'Backend'),          -- 5
(3, 'Frontend'),         -- 6

(2, 'Travel'),           -- 7
(2, 'Food');             -- 8
```

---



**案例1 : 查询出订单数 > 5 的活跃用户**

方式1. 不使用CTE

```sql
SELECT
	* 
FROM
	users 
WHERE
	( profile -> 'active' ) :: BOOLEAN = TRUE 
	AND ID IN (
	SELECT 
		t.user_id 
	FROM
		( SELECT user_id, COUNT ( * ) FROM orders GROUP BY user_id HAVING COUNT ( * ) > 5 ) t 
	);
	
	
-- 写法2
SELECT
	u.* 
FROM
	users u
	INNER JOIN ( SELECT user_id, COUNT ( * ) FROM orders GROUP BY user_id HAVING COUNT ( * ) > 5 ) T ON u.ID = T.user_id 
WHERE
	( u.profile -> 'active' ) :: BOOLEAN = TRUE;
```

改写成CTE写法:

```sql
with tmp as (SELECT user_id,count(*) FROM orders GROUP BY user_id having count(*) > 5 )
SELECT * FROM users  WHERE id in (select user_id from tmp) and (profile->'active')::bool = true ;
```

> [!NOTE]
>
> 注意: `IN` 后面只能是：值列表 或 子查询
>  不能直接写 CTE 名字

CTE写法2:

```sql
with tmp as (SELECT user_id,count(*) FROM orders GROUP BY user_id having count(*) > 5 )
SELECT u.* FROM users u inner join tmp on u.id=tmp.user_id WHERE (u.profile->'active')::boolean is true;
```



**案例2: 找出未激活但是下过单的用户**

```sql
with t as (SELECT distinct user_id FROM orders)
SELECT * FROM users WHERE id in (select user_id from t) and (profile->'active')::bool is false;

-- 或者
with t as (SELECT distinct user_id FROM orders)
SELECT u.* FROM users u inner join t on u.id=t.user_id WHERE (u.profile->'active')::bool is false;
```

## 7. exists用法

### 7.1 基本介绍和语法

> **`EXISTS` 只关心一件事：子查询「有没有返回至少一行」**

- 返回 ≥ 1 行 → `TRUE`
- 返回 0 行 → `FALSE`
- **不关心子查询具体返回什么**

最基础语法:

```sql
SELECT *
FROM table_a a
WHERE EXISTS (
  SELECT 1
  FROM table_b b
  WHERE b.a_id = a.id
);

```

为什么 `SELECT 1`？

- 只是占位
- 写 `*`、`1`、`NULL` 都一样
- 老习惯：`SELECT 1`

查询下过单的用户:

```sql
SELECT u.* FROM users u 
WHERE exists 
(SELECT 1 FROM orders o WHERE o.user_id = u.id );
```

## 8. 函数

### 8.1  upper 和 lower

```
mydb=# SELECT name , UPPER(name) upper_name , LOWER(name) lower_name FROM users;
 name  | upper_name | lower_name
-------+------------+------------
 Alice | ALICE      | alice
 Bob   | BOB        | bob
 Carol | CAROL      | carol
 Dave  | DAVE       | dave
 Eve   | EVE        | eve
```

### 8.2 length

```
mydb=# SELECT name , length(name) len from users ORDER BY len desc;
 name  | len
-------+-----
 Alice |   5
 Carol |   5
 Dave  |   4
 Bob   |   3
 Eve   |   3
(5 行记录)
```

### 8.3 concat

```
mydb=# SELECT concat(name,',,','--','++',id) FROM users;
    concat
--------------
 Alice,,--++1
 Bob,,--++2
 Carol,,--++3
 Dave,,--++4
 Eve,,--++5
(5 行记录)
```

concat可以接收多个参数

### 8.4 substring

```
mydb=# SELECT name, substring(name from 1 for 3) sub FROM users;
 name  | sub
-------+-----
 Alice | Ali
 Bob   | Bob
 Carol | Car
 Dave  | Dav
 Eve   | Eve
(5 行记录)
```

注意: from的下标是从1 开始 不是0开始

### 8.5 trim

```sql
select trim('   hello  world  ') as s;
```

## 9. 集合运算符

### 9.1 UNION和UNION ALL

```sql
SELECT name FROM hr_emps
UNION
SELECT name FROM it_emps;
```

UNION会去除重复项

```sql
SELECT name FROM hr_emps
UNION ALL
SELECT name FROM it_emps;
```

UNION ALL 不会去除重复项



### 9.2 INTERSECT

INTERSECT 返回两个集合的交集, 并且有去重效果

```sql
SELECT name FROM hr_emps
INTERSECT 
SELECT name FROM it_emps;
```

### 9.3 EXCEPT

EXCEPT 返回在第一个表出现, 但是不在第二个表出现的结果, 并且有去重效果

```sql
SELECT name FROM hr_emps
EXCEPT 
SELECT name FROM it_emps;
```

## 10. 高级SQL

### 10.1 序列

#### 10.1.1 序列的基本用法

```sql
-- 创建一个序列
CREATE SEQUENCE my_seq START 10 INCREMENT 20;

-- 创建一个测试表
CREATE TABLE tests (
	id bigserial PRIMARY KEY,
	no int
);

-- 插入数据
INSERT INTO tests (no) values( nextval('my_seq') );
INSERT INTO tests (no) values( nextval('my_seq') );
INSERT INTO tests (no) values( nextval('my_seq') );
INSERT INTO tests (no) values( nextval('my_seq') );
```

#### 10.1.4 修改序列值

查询当前的序列值:

```sql
SELECT CURRVAL('my_seq');
```

将下一个序列值重置为100: 

```sql
ALTER SEQUENCE my_seq RESTART WITH 100;
-- 或者
select setval('my_seq', 100, false);
```

> [!CAUTION]
>
> **注意**:
>
> | 写法                                | 类型 | 下次 nextval 返回 |
> | ----------------------------------- | ---- | ----------------- |
> | ALTER SEQUENCE ... RESTART WITH 100 | DDL  | 100               |
> | setval('my_seq', 100, false)        | 函数 | 100               |
> | setval('my_seq', 100, true)         | 函数 | 100的下一个序列值 |
>
> 如果`setval`只传两个参数: `select setval('my_seq', 100);` , 第三个参数默认为`true`
>
> ---
>
> 
>
> `setval`为什么前面要加 `select`？
>
> setval: 是一个 **函数（function）**，不是语句。
>
> 在 PostgreSQL 里：
>
> - 调函数必须用 `SELECT`
> - 或在 PL/pgSQL 里用 `PERFORM`
>
> ---
>
>  
>
> ✅ **推荐场景**
>
> | 场景                             | 推荐           |
> | -------------------------------- | -------------- |
> | 重置表自增ID或者清空表后重置序列 | ALTER SEQUENCE |
> | 批量修正序列值                   | setval         |
> | 根据 max(id) 修复序列            | setval         |

案例: 修正users表的id序列

```sql
-- setval第三个参数为true 
-- 注意: 第二个参数 (select max(id) FROM users) 左右有个括号.
-- 原因: 本质是：函数参数里放子查询时，SQL 语法要求必须加括号。
SELECT setval('users_id_seq', (select max(id) FROM users), true);
```

案例: 项目需求中要求用户表的id从100000开始

```sql
ALTER SEQUENCE users_id_seq RESTART WITH 100000;
```



## 99. GORM中使用pgsql

```go
package main

import (
	"encoding/json"
	"fmt"
	"github.com/lib/pq"
	"gorm.io/datatypes"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	"gorm.io/plugin/soft_delete"
	"time"
)

type BaseModel struct {
	ID        uint                  `json:"id" msgpack:"id" gorm:"primarykey"`                         // 主键ID
	CreatedAt int64                 `json:"createdAt" msgpack:"createdAt" gorm:"autoCreateTime:milli"` // 使用时间戳毫秒数填充创建时间
	UpdatedAt int64                 `json:"updatedAt" msgpack:"updatedAt" gorm:"autoUpdateTime:milli"` // 使用时间戳毫秒数填充更新时间
	DeletedAt soft_delete.DeletedAt `json:"deletedAt" msgpack:"deletedAt" gorm:"softDelete:milli;index;default:0"`
}

type SysUser struct {
	BaseModel
	UserName string `json:"userName"  gorm:"type:varchar(255)"`
	// 字符串数组
	Tags pq.StringArray `gorm:"type:text[];"`
	// 数字数组
	Scores pq.Int32Array `gorm:"type:int[];"`
	//  type JSONMap map[string]interface{}
	Extra datatypes.JSONMap `gorm:"type:jsonb;default:'{}';"`
	// []byte json
	Abc datatypes.JSON `gorm:"type:jsonb;default:'[]';"`
}

// 指定schema
func (SysUser) TableName() string {
	return "admin.sys_users"
}

// 没有指定schema的表按照 search_path = "app,admin,public" 的顺序进行查找
type User struct {
	BaseModel
	UserName string `json:"userName"  gorm:"type:varchar(255)"`
}

var globalDB *gorm.DB

func main() {

	// https://github.com/go-gorm/postgres
	gormConfig := &gorm.Config{
		/*
			GORM 在应用层缓存 prepared statement
			减少 SQL parse
			明显提升高并发性能
		*/
		PrepareStmt:                              true,
		SkipDefaultTransaction:                   true,
		DisableForeignKeyConstraintWhenMigrating: true, // 不生成实体外键
	}

	var (
		host        = "localhost"
		user        = "postgres"
		password    = "123456"
		dbname      = "mydb"
		port        = 5432
		search_path = "app,admin,public"
	)
	dsn := fmt.Sprintf("host=%s user=%s password=%s dbname=%s port=%d sslmode=disable TimeZone=Asia/Shanghai search_path=%s", host, user, password, dbname, port, search_path)

	db, err := gorm.Open(postgres.New(postgres.Config{
		DSN:                  dsn,
		PreferSimpleProtocol: false, //
	}), gormConfig)
	if err != nil {
		panic("gorm.Open error: " + err.Error())
	}

	sqlDB, err := db.DB()
	if err != nil {
		panic("db.DB() error: " + err.Error())
	}
	if err := sqlDB.Ping(); err != nil {
		panic("sqlDB.Ping() error: " + err.Error())
	}

	// SetMaxIdleConns 用于设置连接池中空闲连接的最大数量。
	sqlDB.SetMaxIdleConns(10)

	// SetMaxOpenConns 设置打开数据库连接的最大数量。
	sqlDB.SetMaxOpenConns(100)

	// SetConnMaxLifetime 设置了连接可复用的最大时间。
	sqlDB.SetConnMaxLifetime(time.Hour)

	// 创建schema
	db.Exec("create schema if not exists app")
	db.Exec("create schema if not exists admin")

	// 数据迁移
	if err := db.AutoMigrate(&SysUser{}, &User{}); err != nil {
		panic("db.AutoMigrate() error: " + err.Error())
	}

	// 添加GIN索引
	db.Exec(`create index if not exists idx_user_extra on sys_users USING gin(extra)`)

	globalDB = db

	Insert()
	Query()
}

func Insert() {
	globalDB.Create(&SysUser{
		UserName: "狗娃",
		Tags:     []string{"苹果", "香蕉"},
		Scores:   []int32{1, 2, 32},
		Extra: map[string]interface{}{
			"name": "xx",
			"age":  18,
		},
	})
	globalDB.Create(&SysUser{
		UserName: "张三",
		Tags:     []string{"Apple", "balana"},
		Scores:   []int32{1, 2, 32},
		Extra: map[string]interface{}{
			"name": "zhangsan",
			"age":  20,
		},
	})
	abc := []map[string]interface{}{
		{"aa": "xxx", "bb": 18},
		{"cc": "lisi", "dd": 20},
	}
	bytes, _ := json.Marshal(abc)
	globalDB.Create(&SysUser{
		UserName: "李四",
		Tags:     []string{"sleep", "ok"},
		Scores:   []int32{1, 123, 32},
		Extra: map[string]interface{}{
			"name": "li",
			"age":  15,
		},
		Abc: bytes,
	})

	globalDB.Create(&User{UserName: "test"})
}

func Query() {
	var u SysUser
	// globalDB.Last(&u)
	// fmt.Println(u)

	// globalDB.Where("extra->>'name' = ?", "zhangsan").First(&u)
	fmt.Println(u)

	var users []SysUser
	globalDB.Where("(extra->>'age')::int <= ?", 19).Find(&users)
	for _, i := range users {
		fmt.Println(i)

	}

	var u2 User
	globalDB.Last(&u2)
	fmt.Println(u2)
}

```

